// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: KRPC.proto

#ifndef PROTOBUF_KRPC_2eproto__INCLUDED
#define PROTOBUF_KRPC_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace KRPC {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_KRPC_2eproto();
void protobuf_AssignDesc_KRPC_2eproto();
void protobuf_ShutdownFile_KRPC_2eproto();

class Request;
class Argument;
class Response;
class StreamMessage;
class StreamResponse;
class Services;
class Service;
class Procedure;
class Parameter;
class Class;
class Enumeration;
class EnumerationValue;
class List;
class Dictionary;
class DictionaryEntry;
class Set;
class Tuple;
class Status;

// ===================================================================

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string service = 1;
  inline bool has_service() const;
  inline void clear_service();
  static const int kServiceFieldNumber = 1;
  inline const ::std::string& service() const;
  inline void set_service(const ::std::string& value);
  inline void set_service(const char* value);
  inline void set_service(const char* value, size_t size);
  inline ::std::string* mutable_service();
  inline ::std::string* release_service();
  inline void set_allocated_service(::std::string* service);

  // required string procedure = 2;
  inline bool has_procedure() const;
  inline void clear_procedure();
  static const int kProcedureFieldNumber = 2;
  inline const ::std::string& procedure() const;
  inline void set_procedure(const ::std::string& value);
  inline void set_procedure(const char* value);
  inline void set_procedure(const char* value, size_t size);
  inline ::std::string* mutable_procedure();
  inline ::std::string* release_procedure();
  inline void set_allocated_procedure(::std::string* procedure);

  // repeated .KRPC.Argument arguments = 3;
  inline int arguments_size() const;
  inline void clear_arguments();
  static const int kArgumentsFieldNumber = 3;
  inline const ::KRPC::Argument& arguments(int index) const;
  inline ::KRPC::Argument* mutable_arguments(int index);
  inline ::KRPC::Argument* add_arguments();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Argument >&
      arguments() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::Argument >*
      mutable_arguments();

  // @@protoc_insertion_point(class_scope:KRPC.Request)
 private:
  inline void set_has_service();
  inline void clear_has_service();
  inline void set_has_procedure();
  inline void clear_has_procedure();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* service_;
  ::std::string* procedure_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::Argument > arguments_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::Message {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Argument& default_instance();

  void Swap(Argument* other);

  // implements Message ----------------------------------------------

  Argument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // required bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:KRPC.Argument)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* value_;
  ::google::protobuf::uint32 position_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Argument* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline double time() const;
  inline void set_time(double value);

  // optional string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional bytes return_value = 3;
  inline bool has_return_value() const;
  inline void clear_return_value();
  static const int kReturnValueFieldNumber = 3;
  inline const ::std::string& return_value() const;
  inline void set_return_value(const ::std::string& value);
  inline void set_return_value(const char* value);
  inline void set_return_value(const void* value, size_t size);
  inline ::std::string* mutable_return_value();
  inline ::std::string* release_return_value();
  inline void set_allocated_return_value(::std::string* return_value);

  // @@protoc_insertion_point(class_scope:KRPC.Response)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_return_value();
  inline void clear_has_return_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double time_;
  ::std::string* error_;
  ::std::string* return_value_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class StreamMessage : public ::google::protobuf::Message {
 public:
  StreamMessage();
  virtual ~StreamMessage();

  StreamMessage(const StreamMessage& from);

  inline StreamMessage& operator=(const StreamMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamMessage& default_instance();

  void Swap(StreamMessage* other);

  // implements Message ----------------------------------------------

  StreamMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamMessage& from);
  void MergeFrom(const StreamMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KRPC.StreamResponse responses = 1;
  inline int responses_size() const;
  inline void clear_responses();
  static const int kResponsesFieldNumber = 1;
  inline const ::KRPC::StreamResponse& responses(int index) const;
  inline ::KRPC::StreamResponse* mutable_responses(int index);
  inline ::KRPC::StreamResponse* add_responses();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::StreamResponse >&
      responses() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::StreamResponse >*
      mutable_responses();

  // @@protoc_insertion_point(class_scope:KRPC.StreamMessage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::StreamResponse > responses_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static StreamMessage* default_instance_;
};
// -------------------------------------------------------------------

class StreamResponse : public ::google::protobuf::Message {
 public:
  StreamResponse();
  virtual ~StreamResponse();

  StreamResponse(const StreamResponse& from);

  inline StreamResponse& operator=(const StreamResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StreamResponse& default_instance();

  void Swap(StreamResponse* other);

  // implements Message ----------------------------------------------

  StreamResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StreamResponse& from);
  void MergeFrom(const StreamResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required .KRPC.Response response = 2;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 2;
  inline const ::KRPC::Response& response() const;
  inline ::KRPC::Response* mutable_response();
  inline ::KRPC::Response* release_response();
  inline void set_allocated_response(::KRPC::Response* response);

  // @@protoc_insertion_point(class_scope:KRPC.StreamResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_response();
  inline void clear_has_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::KRPC::Response* response_;
  ::google::protobuf::uint32 id_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static StreamResponse* default_instance_;
};
// -------------------------------------------------------------------

class Services : public ::google::protobuf::Message {
 public:
  Services();
  virtual ~Services();

  Services(const Services& from);

  inline Services& operator=(const Services& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Services& default_instance();

  void Swap(Services* other);

  // implements Message ----------------------------------------------

  Services* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Services& from);
  void MergeFrom(const Services& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KRPC.Service services = 1;
  inline int services_size() const;
  inline void clear_services();
  static const int kServicesFieldNumber = 1;
  inline const ::KRPC::Service& services(int index) const;
  inline ::KRPC::Service* mutable_services(int index);
  inline ::KRPC::Service* add_services();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Service >&
      services() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::Service >*
      mutable_services();

  // @@protoc_insertion_point(class_scope:KRPC.Services)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::Service > services_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Services* default_instance_;
};
// -------------------------------------------------------------------

class Service : public ::google::protobuf::Message {
 public:
  Service();
  virtual ~Service();

  Service(const Service& from);

  inline Service& operator=(const Service& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Service& default_instance();

  void Swap(Service* other);

  // implements Message ----------------------------------------------

  Service* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Service& from);
  void MergeFrom(const Service& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .KRPC.Procedure procedures = 2;
  inline int procedures_size() const;
  inline void clear_procedures();
  static const int kProceduresFieldNumber = 2;
  inline const ::KRPC::Procedure& procedures(int index) const;
  inline ::KRPC::Procedure* mutable_procedures(int index);
  inline ::KRPC::Procedure* add_procedures();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Procedure >&
      procedures() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::Procedure >*
      mutable_procedures();

  // repeated .KRPC.Class classes = 3;
  inline int classes_size() const;
  inline void clear_classes();
  static const int kClassesFieldNumber = 3;
  inline const ::KRPC::Class& classes(int index) const;
  inline ::KRPC::Class* mutable_classes(int index);
  inline ::KRPC::Class* add_classes();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Class >&
      classes() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::Class >*
      mutable_classes();

  // repeated .KRPC.Enumeration enumerations = 4;
  inline int enumerations_size() const;
  inline void clear_enumerations();
  static const int kEnumerationsFieldNumber = 4;
  inline const ::KRPC::Enumeration& enumerations(int index) const;
  inline ::KRPC::Enumeration* mutable_enumerations(int index);
  inline ::KRPC::Enumeration* add_enumerations();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Enumeration >&
      enumerations() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::Enumeration >*
      mutable_enumerations();

  // @@protoc_insertion_point(class_scope:KRPC.Service)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::Procedure > procedures_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::Class > classes_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::Enumeration > enumerations_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Service* default_instance_;
};
// -------------------------------------------------------------------

class Procedure : public ::google::protobuf::Message {
 public:
  Procedure();
  virtual ~Procedure();

  Procedure(const Procedure& from);

  inline Procedure& operator=(const Procedure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Procedure& default_instance();

  void Swap(Procedure* other);

  // implements Message ----------------------------------------------

  Procedure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Procedure& from);
  void MergeFrom(const Procedure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .KRPC.Parameter parameters = 2;
  inline int parameters_size() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 2;
  inline const ::KRPC::Parameter& parameters(int index) const;
  inline ::KRPC::Parameter* mutable_parameters(int index);
  inline ::KRPC::Parameter* add_parameters();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Parameter >&
      parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::Parameter >*
      mutable_parameters();

  // optional string return_type = 3;
  inline bool has_return_type() const;
  inline void clear_return_type();
  static const int kReturnTypeFieldNumber = 3;
  inline const ::std::string& return_type() const;
  inline void set_return_type(const ::std::string& value);
  inline void set_return_type(const char* value);
  inline void set_return_type(const char* value, size_t size);
  inline ::std::string* mutable_return_type();
  inline ::std::string* release_return_type();
  inline void set_allocated_return_type(::std::string* return_type);

  // repeated string attributes = 4;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 4;
  inline const ::std::string& attributes(int index) const;
  inline ::std::string* mutable_attributes(int index);
  inline void set_attributes(int index, const ::std::string& value);
  inline void set_attributes(int index, const char* value);
  inline void set_attributes(int index, const char* value, size_t size);
  inline ::std::string* add_attributes();
  inline void add_attributes(const ::std::string& value);
  inline void add_attributes(const char* value);
  inline void add_attributes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributes();

  // @@protoc_insertion_point(class_scope:KRPC.Procedure)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_return_type();
  inline void clear_has_return_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::Parameter > parameters_;
  ::std::string* return_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributes_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Procedure* default_instance_;
};
// -------------------------------------------------------------------

class Parameter : public ::google::protobuf::Message {
 public:
  Parameter();
  virtual ~Parameter();

  Parameter(const Parameter& from);

  inline Parameter& operator=(const Parameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parameter& default_instance();

  void Swap(Parameter* other);

  // implements Message ----------------------------------------------

  Parameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parameter& from);
  void MergeFrom(const Parameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional bytes default_argument = 3;
  inline bool has_default_argument() const;
  inline void clear_default_argument();
  static const int kDefaultArgumentFieldNumber = 3;
  inline const ::std::string& default_argument() const;
  inline void set_default_argument(const ::std::string& value);
  inline void set_default_argument(const char* value);
  inline void set_default_argument(const void* value, size_t size);
  inline ::std::string* mutable_default_argument();
  inline ::std::string* release_default_argument();
  inline void set_allocated_default_argument(::std::string* default_argument);

  // @@protoc_insertion_point(class_scope:KRPC.Parameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_default_argument();
  inline void clear_has_default_argument();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* type_;
  ::std::string* default_argument_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Parameter* default_instance_;
};
// -------------------------------------------------------------------

class Class : public ::google::protobuf::Message {
 public:
  Class();
  virtual ~Class();

  Class(const Class& from);

  inline Class& operator=(const Class& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Class& default_instance();

  void Swap(Class* other);

  // implements Message ----------------------------------------------

  Class* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Class& from);
  void MergeFrom(const Class& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:KRPC.Class)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Class* default_instance_;
};
// -------------------------------------------------------------------

class Enumeration : public ::google::protobuf::Message {
 public:
  Enumeration();
  virtual ~Enumeration();

  Enumeration(const Enumeration& from);

  inline Enumeration& operator=(const Enumeration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Enumeration& default_instance();

  void Swap(Enumeration* other);

  // implements Message ----------------------------------------------

  Enumeration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Enumeration& from);
  void MergeFrom(const Enumeration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .KRPC.EnumerationValue values = 2;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 2;
  inline const ::KRPC::EnumerationValue& values(int index) const;
  inline ::KRPC::EnumerationValue* mutable_values(int index);
  inline ::KRPC::EnumerationValue* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::EnumerationValue >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::EnumerationValue >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:KRPC.Enumeration)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::EnumerationValue > values_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Enumeration* default_instance_;
};
// -------------------------------------------------------------------

class EnumerationValue : public ::google::protobuf::Message {
 public:
  EnumerationValue();
  virtual ~EnumerationValue();

  EnumerationValue(const EnumerationValue& from);

  inline EnumerationValue& operator=(const EnumerationValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnumerationValue& default_instance();

  void Swap(EnumerationValue* other);

  // implements Message ----------------------------------------------

  EnumerationValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnumerationValue& from);
  void MergeFrom(const EnumerationValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:KRPC.EnumerationValue)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 value_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static EnumerationValue* default_instance_;
};
// -------------------------------------------------------------------

class List : public ::google::protobuf::Message {
 public:
  List();
  virtual ~List();

  List(const List& from);

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const List& default_instance();

  void Swap(List* other);

  // implements Message ----------------------------------------------

  List* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const List& from);
  void MergeFrom(const List& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::std::string& items(int index) const;
  inline ::std::string* mutable_items(int index);
  inline void set_items(int index, const ::std::string& value);
  inline void set_items(int index, const char* value);
  inline void set_items(int index, const void* value, size_t size);
  inline ::std::string* add_items();
  inline void add_items(const ::std::string& value);
  inline void add_items(const char* value);
  inline void add_items(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:KRPC.List)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static List* default_instance_;
};
// -------------------------------------------------------------------

class Dictionary : public ::google::protobuf::Message {
 public:
  Dictionary();
  virtual ~Dictionary();

  Dictionary(const Dictionary& from);

  inline Dictionary& operator=(const Dictionary& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Dictionary& default_instance();

  void Swap(Dictionary* other);

  // implements Message ----------------------------------------------

  Dictionary* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Dictionary& from);
  void MergeFrom(const Dictionary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KRPC.DictionaryEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::KRPC::DictionaryEntry& entries(int index) const;
  inline ::KRPC::DictionaryEntry* mutable_entries(int index);
  inline ::KRPC::DictionaryEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::KRPC::DictionaryEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::KRPC::DictionaryEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:KRPC.Dictionary)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::KRPC::DictionaryEntry > entries_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Dictionary* default_instance_;
};
// -------------------------------------------------------------------

class DictionaryEntry : public ::google::protobuf::Message {
 public:
  DictionaryEntry();
  virtual ~DictionaryEntry();

  DictionaryEntry(const DictionaryEntry& from);

  inline DictionaryEntry& operator=(const DictionaryEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DictionaryEntry& default_instance();

  void Swap(DictionaryEntry* other);

  // implements Message ----------------------------------------------

  DictionaryEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DictionaryEntry& from);
  void MergeFrom(const DictionaryEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:KRPC.DictionaryEntry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static DictionaryEntry* default_instance_;
};
// -------------------------------------------------------------------

class Set : public ::google::protobuf::Message {
 public:
  Set();
  virtual ~Set();

  Set(const Set& from);

  inline Set& operator=(const Set& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Set& default_instance();

  void Swap(Set* other);

  // implements Message ----------------------------------------------

  Set* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Set& from);
  void MergeFrom(const Set& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::std::string& items(int index) const;
  inline ::std::string* mutable_items(int index);
  inline void set_items(int index, const ::std::string& value);
  inline void set_items(int index, const char* value);
  inline void set_items(int index, const void* value, size_t size);
  inline ::std::string* add_items();
  inline void add_items(const ::std::string& value);
  inline void add_items(const char* value);
  inline void add_items(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:KRPC.Set)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Set* default_instance_;
};
// -------------------------------------------------------------------

class Tuple : public ::google::protobuf::Message {
 public:
  Tuple();
  virtual ~Tuple();

  Tuple(const Tuple& from);

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tuple& default_instance();

  void Swap(Tuple* other);

  // implements Message ----------------------------------------------

  Tuple* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tuple& from);
  void MergeFrom(const Tuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::std::string& items(int index) const;
  inline ::std::string* mutable_items(int index);
  inline void set_items(int index, const ::std::string& value);
  inline void set_items(int index, const char* value);
  inline void set_items(int index, const void* value, size_t size);
  inline ::std::string* add_items();
  inline void add_items(const ::std::string& value);
  inline void add_items(const char* value);
  inline void add_items(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // @@protoc_insertion_point(class_scope:KRPC.Tuple)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Tuple* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:KRPC.Status)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* version_;
  friend void  protobuf_AddDesc_KRPC_2eproto();
  friend void protobuf_AssignDesc_KRPC_2eproto();
  friend void protobuf_ShutdownFile_KRPC_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// ===================================================================


// ===================================================================

// Request

// required string service = 1;
inline bool Request::has_service() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_service() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_service() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_service() {
  if (service_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_->clear();
  }
  clear_has_service();
}
inline const ::std::string& Request::service() const {
  // @@protoc_insertion_point(field_get:KRPC.Request.service)
  return *service_;
}
inline void Request::set_service(const ::std::string& value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_ = new ::std::string;
  }
  service_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Request.service)
}
inline void Request::set_service(const char* value) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_ = new ::std::string;
  }
  service_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Request.service)
}
inline void Request::set_service(const char* value, size_t size) {
  set_has_service();
  if (service_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_ = new ::std::string;
  }
  service_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Request.service)
}
inline ::std::string* Request::mutable_service() {
  set_has_service();
  if (service_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    service_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Request.service)
  return service_;
}
inline ::std::string* Request::release_service() {
  clear_has_service();
  if (service_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = service_;
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_service(::std::string* service) {
  if (service_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete service_;
  }
  if (service) {
    set_has_service();
    service_ = service;
  } else {
    clear_has_service();
    service_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Request.service)
}

// required string procedure = 2;
inline bool Request::has_procedure() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_procedure() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_procedure() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_procedure() {
  if (procedure_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    procedure_->clear();
  }
  clear_has_procedure();
}
inline const ::std::string& Request::procedure() const {
  // @@protoc_insertion_point(field_get:KRPC.Request.procedure)
  return *procedure_;
}
inline void Request::set_procedure(const ::std::string& value) {
  set_has_procedure();
  if (procedure_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    procedure_ = new ::std::string;
  }
  procedure_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Request.procedure)
}
inline void Request::set_procedure(const char* value) {
  set_has_procedure();
  if (procedure_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    procedure_ = new ::std::string;
  }
  procedure_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Request.procedure)
}
inline void Request::set_procedure(const char* value, size_t size) {
  set_has_procedure();
  if (procedure_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    procedure_ = new ::std::string;
  }
  procedure_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Request.procedure)
}
inline ::std::string* Request::mutable_procedure() {
  set_has_procedure();
  if (procedure_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    procedure_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Request.procedure)
  return procedure_;
}
inline ::std::string* Request::release_procedure() {
  clear_has_procedure();
  if (procedure_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = procedure_;
    procedure_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Request::set_allocated_procedure(::std::string* procedure) {
  if (procedure_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete procedure_;
  }
  if (procedure) {
    set_has_procedure();
    procedure_ = procedure;
  } else {
    clear_has_procedure();
    procedure_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Request.procedure)
}

// repeated .KRPC.Argument arguments = 3;
inline int Request::arguments_size() const {
  return arguments_.size();
}
inline void Request::clear_arguments() {
  arguments_.Clear();
}
inline const ::KRPC::Argument& Request::arguments(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Request.arguments)
  return arguments_.Get(index);
}
inline ::KRPC::Argument* Request::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Request.arguments)
  return arguments_.Mutable(index);
}
inline ::KRPC::Argument* Request::add_arguments() {
  // @@protoc_insertion_point(field_add:KRPC.Request.arguments)
  return arguments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Argument >&
Request::arguments() const {
  // @@protoc_insertion_point(field_list:KRPC.Request.arguments)
  return arguments_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::Argument >*
Request::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Request.arguments)
  return &arguments_;
}

// -------------------------------------------------------------------

// Argument

// required uint32 position = 1;
inline bool Argument::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 Argument::position() const {
  // @@protoc_insertion_point(field_get:KRPC.Argument.position)
  return position_;
}
inline void Argument::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:KRPC.Argument.position)
}

// required bytes value = 2;
inline bool Argument::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Argument::value() const {
  // @@protoc_insertion_point(field_get:KRPC.Argument.value)
  return *value_;
}
inline void Argument::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Argument.value)
}
inline void Argument::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Argument.value)
}
inline void Argument::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Argument.value)
}
inline ::std::string* Argument::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Argument.value)
  return value_;
}
inline ::std::string* Argument::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Argument::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Argument.value)
}

// -------------------------------------------------------------------

// Response

// required double time = 1;
inline bool Response::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline double Response::time() const {
  // @@protoc_insertion_point(field_get:KRPC.Response.time)
  return time_;
}
inline void Response::set_time(double value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:KRPC.Response.time)
}

// optional string error = 2;
inline bool Response::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& Response::error() const {
  // @@protoc_insertion_point(field_get:KRPC.Response.error)
  return *error_;
}
inline void Response::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Response.error)
}
inline void Response::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Response.error)
}
inline void Response::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Response.error)
}
inline ::std::string* Response::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Response.error)
  return error_;
}
inline ::std::string* Response::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Response.error)
}

// optional bytes return_value = 3;
inline bool Response::has_return_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_return_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_return_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_return_value() {
  if (return_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_value_->clear();
  }
  clear_has_return_value();
}
inline const ::std::string& Response::return_value() const {
  // @@protoc_insertion_point(field_get:KRPC.Response.return_value)
  return *return_value_;
}
inline void Response::set_return_value(const ::std::string& value) {
  set_has_return_value();
  if (return_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_value_ = new ::std::string;
  }
  return_value_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Response.return_value)
}
inline void Response::set_return_value(const char* value) {
  set_has_return_value();
  if (return_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_value_ = new ::std::string;
  }
  return_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Response.return_value)
}
inline void Response::set_return_value(const void* value, size_t size) {
  set_has_return_value();
  if (return_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_value_ = new ::std::string;
  }
  return_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Response.return_value)
}
inline ::std::string* Response::mutable_return_value() {
  set_has_return_value();
  if (return_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Response.return_value)
  return return_value_;
}
inline ::std::string* Response::release_return_value() {
  clear_has_return_value();
  if (return_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = return_value_;
    return_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Response::set_allocated_return_value(::std::string* return_value) {
  if (return_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete return_value_;
  }
  if (return_value) {
    set_has_return_value();
    return_value_ = return_value;
  } else {
    clear_has_return_value();
    return_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Response.return_value)
}

// -------------------------------------------------------------------

// StreamMessage

// repeated .KRPC.StreamResponse responses = 1;
inline int StreamMessage::responses_size() const {
  return responses_.size();
}
inline void StreamMessage::clear_responses() {
  responses_.Clear();
}
inline const ::KRPC::StreamResponse& StreamMessage::responses(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.StreamMessage.responses)
  return responses_.Get(index);
}
inline ::KRPC::StreamResponse* StreamMessage::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.StreamMessage.responses)
  return responses_.Mutable(index);
}
inline ::KRPC::StreamResponse* StreamMessage::add_responses() {
  // @@protoc_insertion_point(field_add:KRPC.StreamMessage.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::StreamResponse >&
StreamMessage::responses() const {
  // @@protoc_insertion_point(field_list:KRPC.StreamMessage.responses)
  return responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::StreamResponse >*
StreamMessage::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.StreamMessage.responses)
  return &responses_;
}

// -------------------------------------------------------------------

// StreamResponse

// required uint32 id = 1;
inline bool StreamResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamResponse::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 StreamResponse::id() const {
  // @@protoc_insertion_point(field_get:KRPC.StreamResponse.id)
  return id_;
}
inline void StreamResponse::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:KRPC.StreamResponse.id)
}

// required .KRPC.Response response = 2;
inline bool StreamResponse::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamResponse::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamResponse::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamResponse::clear_response() {
  if (response_ != NULL) response_->::KRPC::Response::Clear();
  clear_has_response();
}
inline const ::KRPC::Response& StreamResponse::response() const {
  // @@protoc_insertion_point(field_get:KRPC.StreamResponse.response)
  return response_ != NULL ? *response_ : *default_instance_->response_;
}
inline ::KRPC::Response* StreamResponse::mutable_response() {
  set_has_response();
  if (response_ == NULL) response_ = new ::KRPC::Response;
  // @@protoc_insertion_point(field_mutable:KRPC.StreamResponse.response)
  return response_;
}
inline ::KRPC::Response* StreamResponse::release_response() {
  clear_has_response();
  ::KRPC::Response* temp = response_;
  response_ = NULL;
  return temp;
}
inline void StreamResponse::set_allocated_response(::KRPC::Response* response) {
  delete response_;
  response_ = response;
  if (response) {
    set_has_response();
  } else {
    clear_has_response();
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.StreamResponse.response)
}

// -------------------------------------------------------------------

// Services

// repeated .KRPC.Service services = 1;
inline int Services::services_size() const {
  return services_.size();
}
inline void Services::clear_services() {
  services_.Clear();
}
inline const ::KRPC::Service& Services::services(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Services.services)
  return services_.Get(index);
}
inline ::KRPC::Service* Services::mutable_services(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Services.services)
  return services_.Mutable(index);
}
inline ::KRPC::Service* Services::add_services() {
  // @@protoc_insertion_point(field_add:KRPC.Services.services)
  return services_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Service >&
Services::services() const {
  // @@protoc_insertion_point(field_list:KRPC.Services.services)
  return services_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::Service >*
Services::mutable_services() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Services.services)
  return &services_;
}

// -------------------------------------------------------------------

// Service

// required string name = 1;
inline bool Service::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Service::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Service::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Service::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Service::name() const {
  // @@protoc_insertion_point(field_get:KRPC.Service.name)
  return *name_;
}
inline void Service::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Service.name)
}
inline void Service::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Service.name)
}
inline void Service::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Service.name)
}
inline ::std::string* Service::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Service.name)
  return name_;
}
inline ::std::string* Service::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Service::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Service.name)
}

// repeated .KRPC.Procedure procedures = 2;
inline int Service::procedures_size() const {
  return procedures_.size();
}
inline void Service::clear_procedures() {
  procedures_.Clear();
}
inline const ::KRPC::Procedure& Service::procedures(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Service.procedures)
  return procedures_.Get(index);
}
inline ::KRPC::Procedure* Service::mutable_procedures(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Service.procedures)
  return procedures_.Mutable(index);
}
inline ::KRPC::Procedure* Service::add_procedures() {
  // @@protoc_insertion_point(field_add:KRPC.Service.procedures)
  return procedures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Procedure >&
Service::procedures() const {
  // @@protoc_insertion_point(field_list:KRPC.Service.procedures)
  return procedures_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::Procedure >*
Service::mutable_procedures() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Service.procedures)
  return &procedures_;
}

// repeated .KRPC.Class classes = 3;
inline int Service::classes_size() const {
  return classes_.size();
}
inline void Service::clear_classes() {
  classes_.Clear();
}
inline const ::KRPC::Class& Service::classes(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Service.classes)
  return classes_.Get(index);
}
inline ::KRPC::Class* Service::mutable_classes(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Service.classes)
  return classes_.Mutable(index);
}
inline ::KRPC::Class* Service::add_classes() {
  // @@protoc_insertion_point(field_add:KRPC.Service.classes)
  return classes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Class >&
Service::classes() const {
  // @@protoc_insertion_point(field_list:KRPC.Service.classes)
  return classes_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::Class >*
Service::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Service.classes)
  return &classes_;
}

// repeated .KRPC.Enumeration enumerations = 4;
inline int Service::enumerations_size() const {
  return enumerations_.size();
}
inline void Service::clear_enumerations() {
  enumerations_.Clear();
}
inline const ::KRPC::Enumeration& Service::enumerations(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Service.enumerations)
  return enumerations_.Get(index);
}
inline ::KRPC::Enumeration* Service::mutable_enumerations(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Service.enumerations)
  return enumerations_.Mutable(index);
}
inline ::KRPC::Enumeration* Service::add_enumerations() {
  // @@protoc_insertion_point(field_add:KRPC.Service.enumerations)
  return enumerations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Enumeration >&
Service::enumerations() const {
  // @@protoc_insertion_point(field_list:KRPC.Service.enumerations)
  return enumerations_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::Enumeration >*
Service::mutable_enumerations() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Service.enumerations)
  return &enumerations_;
}

// -------------------------------------------------------------------

// Procedure

// required string name = 1;
inline bool Procedure::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Procedure::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Procedure::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Procedure::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Procedure::name() const {
  // @@protoc_insertion_point(field_get:KRPC.Procedure.name)
  return *name_;
}
inline void Procedure::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Procedure.name)
}
inline void Procedure::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Procedure.name)
}
inline void Procedure::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Procedure.name)
}
inline ::std::string* Procedure::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Procedure.name)
  return name_;
}
inline ::std::string* Procedure::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Procedure::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Procedure.name)
}

// repeated .KRPC.Parameter parameters = 2;
inline int Procedure::parameters_size() const {
  return parameters_.size();
}
inline void Procedure::clear_parameters() {
  parameters_.Clear();
}
inline const ::KRPC::Parameter& Procedure::parameters(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Procedure.parameters)
  return parameters_.Get(index);
}
inline ::KRPC::Parameter* Procedure::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Procedure.parameters)
  return parameters_.Mutable(index);
}
inline ::KRPC::Parameter* Procedure::add_parameters() {
  // @@protoc_insertion_point(field_add:KRPC.Procedure.parameters)
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::Parameter >&
Procedure::parameters() const {
  // @@protoc_insertion_point(field_list:KRPC.Procedure.parameters)
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::Parameter >*
Procedure::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Procedure.parameters)
  return &parameters_;
}

// optional string return_type = 3;
inline bool Procedure::has_return_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Procedure::set_has_return_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Procedure::clear_has_return_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Procedure::clear_return_type() {
  if (return_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_type_->clear();
  }
  clear_has_return_type();
}
inline const ::std::string& Procedure::return_type() const {
  // @@protoc_insertion_point(field_get:KRPC.Procedure.return_type)
  return *return_type_;
}
inline void Procedure::set_return_type(const ::std::string& value) {
  set_has_return_type();
  if (return_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_type_ = new ::std::string;
  }
  return_type_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Procedure.return_type)
}
inline void Procedure::set_return_type(const char* value) {
  set_has_return_type();
  if (return_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_type_ = new ::std::string;
  }
  return_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Procedure.return_type)
}
inline void Procedure::set_return_type(const char* value, size_t size) {
  set_has_return_type();
  if (return_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_type_ = new ::std::string;
  }
  return_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Procedure.return_type)
}
inline ::std::string* Procedure::mutable_return_type() {
  set_has_return_type();
  if (return_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Procedure.return_type)
  return return_type_;
}
inline ::std::string* Procedure::release_return_type() {
  clear_has_return_type();
  if (return_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = return_type_;
    return_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Procedure::set_allocated_return_type(::std::string* return_type) {
  if (return_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete return_type_;
  }
  if (return_type) {
    set_has_return_type();
    return_type_ = return_type;
  } else {
    clear_has_return_type();
    return_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Procedure.return_type)
}

// repeated string attributes = 4;
inline int Procedure::attributes_size() const {
  return attributes_.size();
}
inline void Procedure::clear_attributes() {
  attributes_.Clear();
}
inline const ::std::string& Procedure::attributes(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Procedure.attributes)
  return attributes_.Get(index);
}
inline ::std::string* Procedure::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Procedure.attributes)
  return attributes_.Mutable(index);
}
inline void Procedure::set_attributes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KRPC.Procedure.attributes)
  attributes_.Mutable(index)->assign(value);
}
inline void Procedure::set_attributes(int index, const char* value) {
  attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Procedure.attributes)
}
inline void Procedure::set_attributes(int index, const char* value, size_t size) {
  attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Procedure.attributes)
}
inline ::std::string* Procedure::add_attributes() {
  return attributes_.Add();
}
inline void Procedure::add_attributes(const ::std::string& value) {
  attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KRPC.Procedure.attributes)
}
inline void Procedure::add_attributes(const char* value) {
  attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KRPC.Procedure.attributes)
}
inline void Procedure::add_attributes(const char* value, size_t size) {
  attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KRPC.Procedure.attributes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Procedure::attributes() const {
  // @@protoc_insertion_point(field_list:KRPC.Procedure.attributes)
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Procedure::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Procedure.attributes)
  return &attributes_;
}

// -------------------------------------------------------------------

// Parameter

// required string name = 1;
inline bool Parameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parameter::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Parameter::name() const {
  // @@protoc_insertion_point(field_get:KRPC.Parameter.name)
  return *name_;
}
inline void Parameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Parameter.name)
}
inline void Parameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Parameter.name)
}
inline void Parameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Parameter.name)
}
inline ::std::string* Parameter::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Parameter.name)
  return name_;
}
inline ::std::string* Parameter::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Parameter::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Parameter.name)
}

// required string type = 2;
inline bool Parameter::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parameter::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parameter::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& Parameter::type() const {
  // @@protoc_insertion_point(field_get:KRPC.Parameter.type)
  return *type_;
}
inline void Parameter::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Parameter.type)
}
inline void Parameter::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Parameter.type)
}
inline void Parameter::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Parameter.type)
}
inline ::std::string* Parameter::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Parameter.type)
  return type_;
}
inline ::std::string* Parameter::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Parameter::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Parameter.type)
}

// optional bytes default_argument = 3;
inline bool Parameter::has_default_argument() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Parameter::set_has_default_argument() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Parameter::clear_has_default_argument() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Parameter::clear_default_argument() {
  if (default_argument_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_argument_->clear();
  }
  clear_has_default_argument();
}
inline const ::std::string& Parameter::default_argument() const {
  // @@protoc_insertion_point(field_get:KRPC.Parameter.default_argument)
  return *default_argument_;
}
inline void Parameter::set_default_argument(const ::std::string& value) {
  set_has_default_argument();
  if (default_argument_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_argument_ = new ::std::string;
  }
  default_argument_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Parameter.default_argument)
}
inline void Parameter::set_default_argument(const char* value) {
  set_has_default_argument();
  if (default_argument_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_argument_ = new ::std::string;
  }
  default_argument_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Parameter.default_argument)
}
inline void Parameter::set_default_argument(const void* value, size_t size) {
  set_has_default_argument();
  if (default_argument_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_argument_ = new ::std::string;
  }
  default_argument_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Parameter.default_argument)
}
inline ::std::string* Parameter::mutable_default_argument() {
  set_has_default_argument();
  if (default_argument_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    default_argument_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Parameter.default_argument)
  return default_argument_;
}
inline ::std::string* Parameter::release_default_argument() {
  clear_has_default_argument();
  if (default_argument_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = default_argument_;
    default_argument_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Parameter::set_allocated_default_argument(::std::string* default_argument) {
  if (default_argument_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete default_argument_;
  }
  if (default_argument) {
    set_has_default_argument();
    default_argument_ = default_argument;
  } else {
    clear_has_default_argument();
    default_argument_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Parameter.default_argument)
}

// -------------------------------------------------------------------

// Class

// required string name = 1;
inline bool Class::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Class::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Class::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Class::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Class::name() const {
  // @@protoc_insertion_point(field_get:KRPC.Class.name)
  return *name_;
}
inline void Class::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Class.name)
}
inline void Class::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Class.name)
}
inline void Class::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Class.name)
}
inline ::std::string* Class::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Class.name)
  return name_;
}
inline ::std::string* Class::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Class::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Class.name)
}

// -------------------------------------------------------------------

// Enumeration

// required string name = 1;
inline bool Enumeration::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Enumeration::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Enumeration::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Enumeration::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Enumeration::name() const {
  // @@protoc_insertion_point(field_get:KRPC.Enumeration.name)
  return *name_;
}
inline void Enumeration::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Enumeration.name)
}
inline void Enumeration::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Enumeration.name)
}
inline void Enumeration::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Enumeration.name)
}
inline ::std::string* Enumeration::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Enumeration.name)
  return name_;
}
inline ::std::string* Enumeration::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Enumeration::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Enumeration.name)
}

// repeated .KRPC.EnumerationValue values = 2;
inline int Enumeration::values_size() const {
  return values_.size();
}
inline void Enumeration::clear_values() {
  values_.Clear();
}
inline const ::KRPC::EnumerationValue& Enumeration::values(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Enumeration.values)
  return values_.Get(index);
}
inline ::KRPC::EnumerationValue* Enumeration::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Enumeration.values)
  return values_.Mutable(index);
}
inline ::KRPC::EnumerationValue* Enumeration::add_values() {
  // @@protoc_insertion_point(field_add:KRPC.Enumeration.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::EnumerationValue >&
Enumeration::values() const {
  // @@protoc_insertion_point(field_list:KRPC.Enumeration.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::EnumerationValue >*
Enumeration::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Enumeration.values)
  return &values_;
}

// -------------------------------------------------------------------

// EnumerationValue

// required string name = 1;
inline bool EnumerationValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumerationValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumerationValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumerationValue::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& EnumerationValue::name() const {
  // @@protoc_insertion_point(field_get:KRPC.EnumerationValue.name)
  return *name_;
}
inline void EnumerationValue::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.EnumerationValue.name)
}
inline void EnumerationValue::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.EnumerationValue.name)
}
inline void EnumerationValue::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.EnumerationValue.name)
}
inline ::std::string* EnumerationValue::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.EnumerationValue.name)
  return name_;
}
inline ::std::string* EnumerationValue::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EnumerationValue::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.EnumerationValue.name)
}

// required int32 value = 2;
inline bool EnumerationValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnumerationValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnumerationValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnumerationValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 EnumerationValue::value() const {
  // @@protoc_insertion_point(field_get:KRPC.EnumerationValue.value)
  return value_;
}
inline void EnumerationValue::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:KRPC.EnumerationValue.value)
}

// -------------------------------------------------------------------

// List

// repeated bytes items = 1;
inline int List::items_size() const {
  return items_.size();
}
inline void List::clear_items() {
  items_.Clear();
}
inline const ::std::string& List::items(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.List.items)
  return items_.Get(index);
}
inline ::std::string* List::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.List.items)
  return items_.Mutable(index);
}
inline void List::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KRPC.List.items)
  items_.Mutable(index)->assign(value);
}
inline void List::set_items(int index, const char* value) {
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.List.items)
}
inline void List::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.List.items)
}
inline ::std::string* List::add_items() {
  return items_.Add();
}
inline void List::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KRPC.List.items)
}
inline void List::add_items(const char* value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KRPC.List.items)
}
inline void List::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KRPC.List.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
List::items() const {
  // @@protoc_insertion_point(field_list:KRPC.List.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
List::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.List.items)
  return &items_;
}

// -------------------------------------------------------------------

// Dictionary

// repeated .KRPC.DictionaryEntry entries = 1;
inline int Dictionary::entries_size() const {
  return entries_.size();
}
inline void Dictionary::clear_entries() {
  entries_.Clear();
}
inline const ::KRPC::DictionaryEntry& Dictionary::entries(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Dictionary.entries)
  return entries_.Get(index);
}
inline ::KRPC::DictionaryEntry* Dictionary::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Dictionary.entries)
  return entries_.Mutable(index);
}
inline ::KRPC::DictionaryEntry* Dictionary::add_entries() {
  // @@protoc_insertion_point(field_add:KRPC.Dictionary.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KRPC::DictionaryEntry >&
Dictionary::entries() const {
  // @@protoc_insertion_point(field_list:KRPC.Dictionary.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::KRPC::DictionaryEntry >*
Dictionary::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Dictionary.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// DictionaryEntry

// required bytes key = 1;
inline bool DictionaryEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DictionaryEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DictionaryEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DictionaryEntry::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& DictionaryEntry::key() const {
  // @@protoc_insertion_point(field_get:KRPC.DictionaryEntry.key)
  return *key_;
}
inline void DictionaryEntry::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.DictionaryEntry.key)
}
inline void DictionaryEntry::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.DictionaryEntry.key)
}
inline void DictionaryEntry::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.DictionaryEntry.key)
}
inline ::std::string* DictionaryEntry::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.DictionaryEntry.key)
  return key_;
}
inline ::std::string* DictionaryEntry::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DictionaryEntry::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.DictionaryEntry.key)
}

// required bytes value = 2;
inline bool DictionaryEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DictionaryEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DictionaryEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DictionaryEntry::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& DictionaryEntry::value() const {
  // @@protoc_insertion_point(field_get:KRPC.DictionaryEntry.value)
  return *value_;
}
inline void DictionaryEntry::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.DictionaryEntry.value)
}
inline void DictionaryEntry::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.DictionaryEntry.value)
}
inline void DictionaryEntry::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.DictionaryEntry.value)
}
inline ::std::string* DictionaryEntry::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.DictionaryEntry.value)
  return value_;
}
inline ::std::string* DictionaryEntry::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DictionaryEntry::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.DictionaryEntry.value)
}

// -------------------------------------------------------------------

// Set

// repeated bytes items = 1;
inline int Set::items_size() const {
  return items_.size();
}
inline void Set::clear_items() {
  items_.Clear();
}
inline const ::std::string& Set::items(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Set.items)
  return items_.Get(index);
}
inline ::std::string* Set::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Set.items)
  return items_.Mutable(index);
}
inline void Set::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KRPC.Set.items)
  items_.Mutable(index)->assign(value);
}
inline void Set::set_items(int index, const char* value) {
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Set.items)
}
inline void Set::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Set.items)
}
inline ::std::string* Set::add_items() {
  return items_.Add();
}
inline void Set::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KRPC.Set.items)
}
inline void Set::add_items(const char* value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KRPC.Set.items)
}
inline void Set::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KRPC.Set.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Set::items() const {
  // @@protoc_insertion_point(field_list:KRPC.Set.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Set::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Set.items)
  return &items_;
}

// -------------------------------------------------------------------

// Tuple

// repeated bytes items = 1;
inline int Tuple::items_size() const {
  return items_.size();
}
inline void Tuple::clear_items() {
  items_.Clear();
}
inline const ::std::string& Tuple::items(int index) const {
  // @@protoc_insertion_point(field_get:KRPC.Tuple.items)
  return items_.Get(index);
}
inline ::std::string* Tuple::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:KRPC.Tuple.items)
  return items_.Mutable(index);
}
inline void Tuple::set_items(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KRPC.Tuple.items)
  items_.Mutable(index)->assign(value);
}
inline void Tuple::set_items(int index, const char* value) {
  items_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Tuple.items)
}
inline void Tuple::set_items(int index, const void* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Tuple.items)
}
inline ::std::string* Tuple::add_items() {
  return items_.Add();
}
inline void Tuple::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KRPC.Tuple.items)
}
inline void Tuple::add_items(const char* value) {
  items_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KRPC.Tuple.items)
}
inline void Tuple::add_items(const void* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KRPC.Tuple.items)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Tuple::items() const {
  // @@protoc_insertion_point(field_list:KRPC.Tuple.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Tuple::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:KRPC.Tuple.items)
  return &items_;
}

// -------------------------------------------------------------------

// Status

// required string version = 1;
inline bool Status::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Status::version() const {
  // @@protoc_insertion_point(field_get:KRPC.Status.version)
  return *version_;
}
inline void Status::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:KRPC.Status.version)
}
inline void Status::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:KRPC.Status.version)
}
inline void Status::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KRPC.Status.version)
}
inline ::std::string* Status::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:KRPC.Status.version)
  return version_;
}
inline ::std::string* Status::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Status::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:KRPC.Status.version)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace KRPC

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_KRPC_2eproto__INCLUDED
